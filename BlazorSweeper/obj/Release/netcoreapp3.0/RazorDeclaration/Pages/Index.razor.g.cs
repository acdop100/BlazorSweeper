#pragma checksum "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\Pages\Index.razor" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "a02a83c808077300a769d5b4cb1ed2258b71d8dc"
// <auto-generated/>
#pragma warning disable 1591
#pragma warning disable 0414
#pragma warning disable 0649
#pragma warning disable 0169

namespace BlazorSweeper.Pages
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Components;
#line 1 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\_Imports.razor"
using System.Net.Http;

#line default
#line hidden
#line 2 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\_Imports.razor"
using Microsoft.AspNetCore.Components.Forms;

#line default
#line hidden
#line 3 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\_Imports.razor"
using Microsoft.AspNetCore.Components.Layouts;

#line default
#line hidden
#line 4 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\_Imports.razor"
using Microsoft.AspNetCore.Components.Routing;

#line default
#line hidden
#line 5 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\_Imports.razor"
using Microsoft.JSInterop;

#line default
#line hidden
#line 6 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\_Imports.razor"
using BlazorSweeper;

#line default
#line hidden
#line 7 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\_Imports.razor"
using BlazorSweeper.Shared;

#line default
#line hidden
#line 2 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\Pages\Index.razor"
using BlazorSweeper.Data;

#line default
#line hidden
    [Microsoft.AspNetCore.Components.Layouts.LayoutAttribute(typeof(MainLayout))]
    [Microsoft.AspNetCore.Components.RouteAttribute("/")]
    public class Index : Microsoft.AspNetCore.Components.ComponentBase
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(Microsoft.AspNetCore.Components.RenderTree.RenderTreeBuilder builder)
        {
        }
        #pragma warning restore 1998
#line 33 "C:\Users\p3yoc\Source\Repos\acdop100\BlazorSweeper\BlazorSweeper\Pages\Index.razor"
       

    // Some variables to make development easier.
    Board ThisBoard;
    bool GameOver;
    string BannerText;
    double GameDisplay;
    int Neighbors;

    // Runs on page render.
    override protected void OnInit()
    {
        NewGame();
    }

    // This is a separate function because this is run when the page is rendered or when the user wants to start a new game.
    public void NewGame()
    {
        BannerText = "Welcome To BlazorSweeper";
        ThisBoard = new Board();
        GameOver = false;
        GameDisplay = 1;
    }

    // Run whenever the user clicks on a square.
    private void MakeMove(UIMouseEventArgs click, Spaces space)
    {

        // Left clicking on a non-flagged square will open it.
        if ((click.Button == 0) && (!click.CtrlKey) && (!space.Flagged))
        {
            if (space.HasMine)
            {
                BannerText = "You lost.";
                GameOver = true;
                GameDisplay = 0.5;
                space.Color = "red;";

                // Turn all mines red, even ones not clicked. If you flagged a mine, it turns green, but if you flag a bad space it turns purple.
                for (int i = 0; i < 10; i++)
                {
                    for (int j = 0; j < 10; j++)
                    {
                        if (ThisBoard.BoardSpace[i, j].HasMine)
                        {
                            ThisBoard.BoardSpace[i, j].Color = "red;";
                        }
                        if (ThisBoard.BoardSpace[i, j].Flagged)
                        {
                            if (ThisBoard.BoardSpace[i, j].HasMine)
                            {
                                ThisBoard.BoardSpace[i, j].Color = "green;";
                            }
                            else
                            {
                                ThisBoard.BoardSpace[i, j].Color = "purple;";
                            }
                        }
                    }
                }
            }
            else
            {
                CheckNeighbors(space);
            }
        }
        // Right clicking flags the square.
        else if (click.Button == 0 && click.CtrlKey)
        {
            if (space.Flagged)
            {
                space.Flagged = false;
                space.Color = "gray;";
                if (space.HasMine)
                {
                    ThisBoard.FlagNums--;
                }
            }
            else
            {
                space.Flagged = true;
                space.Color = "blue;";

                if (space.HasMine)
                {
                    ThisBoard.FlagNums++;
                }

                if (ThisBoard.FlagNums == ThisBoard.MineNums)
                {
                    GameOver = true;
                    BannerText = "You Won!";
                    GameDisplay = 0.5;
                    for (int i = 0; i < 10; i++)
                    {
                        for (int j = 0; j < 10; j++)
                        {
                            if (ThisBoard.BoardSpace[i, j].Flagged)
                            {
                                ThisBoard.BoardSpace[i, j].Color = "green;";
                            }
                        }
                    }
                }
            }

        }
    }

    // This function checks all of the clicked space's neighbors to see how many neighbors have bombs.
    private void CheckNeighbors(Spaces space)
    {
        Neighbors = 0;
        // We need to check whether the neighboring space we are checking actually exists. For example we can check any neighbors above a square if the square in question is on the top row.
        if (space.Y - 1 >= 0)
        {
            if (space.X - 1 >= 0)
            {
                CheckSpecificNeighbor(ThisBoard.BoardSpace[space.X - 1, space.Y - 1], space);
            }
            if (space.X >= 0)
            {
                CheckSpecificNeighbor(ThisBoard.BoardSpace[space.X, space.Y - 1], space);
            }
            if (space.X + 1 < 10)
            {
                CheckSpecificNeighbor(ThisBoard.BoardSpace[space.X + 1, space.Y - 1], space);
            }
        }
        if (space.Y >= 0)
        {
            if (space.X - 1 >= 0)
            {
                CheckSpecificNeighbor(ThisBoard.BoardSpace[space.X - 1, space.Y], space);
            }
            if (space.X + 1 < 10)
            {
                CheckSpecificNeighbor(ThisBoard.BoardSpace[space.X + 1, space.Y], space);
            }

        }
        if (space.Y + 1 < 10)
        {
            if (space.X - 1 >= 0)
            {
                CheckSpecificNeighbor(ThisBoard.BoardSpace[space.X - 1, space.Y + 1], space);
            }
            if (space.X >= 0)
            {
                CheckSpecificNeighbor(ThisBoard.BoardSpace[space.X, space.Y + 1], space);
            }
            if (space.X + 1 < 10)
            {
                CheckSpecificNeighbor(ThisBoard.BoardSpace[space.X + 1, space.Y + 1], space);
            }
        }
        space.KnownNeighbors = Neighbors.ToString();
        space.Color = "white;";
        space.Checked = true;

        // If the square had zero neighbors with mines, then go ahead and check all of those.
        if (Neighbors == 0)
        {
            foreach (Spaces spaces in space.NeighborSpaces)
            {
                // Check to see if the neighbor of the zero square has already been checked, otherwise the recursion will never end.
                if ((spaces.Checked == false) && (spaces.Flagged == false))
                {
                    CheckNeighbors(spaces);
                }
            }
        }
    }

    // Function to decide what to do if a neighbor has a mine or not.
    private void CheckSpecificNeighbor(Spaces TempSpace, Spaces space)
    {
        if (TempSpace.HasMine)
        {
            Neighbors++;
        }
        else
        {
            space.NeighborSpaces.Add(TempSpace);
        }
    }


#line default
#line hidden
    }
}
#pragma warning restore 1591
